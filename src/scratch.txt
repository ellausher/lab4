Analysera de beroenden som finns med avseende på cohesion och coupling, och Dependency Inversion Principle.

cohesion:
    Vehicle klasserna gör det bra. Dom beskriver hur en typ av vehicle fungerar, metoderna är specifika för klassen.
    CarController: gör lite allt möjligt, låg cohesion, gör knapparna och lägger in bilarna "fysiskt", sätter position och in i arraylist osv. Kör main också.
    DrawPanel: Gör rendering, moveit, laddar bilder. Inte jättebra.
    CarView: hög gör layout.
coupling:
    Hög koppling. Mycket beroenden som gör så att vi inte kan använda klasserna "standalone". De anropar varandra och beror på varandra. Använder t.ex. Vehicle på många ställen.
DIP:
    Allt beror på specifika implementationer. dåligt!

Vilka beroenden är nödvändiga?
Subtypspolymorfism med Vehicle. Movable --> Vehicle abstraktion. Interfaces som säkerställer beteenden.
Vilka klasser är beroende av varandra som inte borde vara det?
CarController är cirkulärt beroende till CarView. CarController till Drawpanel, behöver inte känna till varandra.
Finns det starkare beroenden än nödvändigt?
Ja.
Kan ni identifiera några brott mot övriga designprinciper vi pratat om i kursen?
OCP: hårdkodade värden och typer (t.ex. bestämt att det är en scania, volvoworkshop, x och y värden)

Analysera era klasser med avseende på Separation of Concern (SoC) och Single Responsibility Principle (SRP).
Vilka ansvarsområden har era klasser?
CarController gör mycket: domänregler (köra utanför fönster), UI uppdatering, Simulering/loop, håller bilar, skapar koordinater osv.
Vilka anledningar har de att förändras?
CarController: om vi byter något av beroenden så måste vi ändra i koden, till exemple byta från Swing, bounds, nya knappar, andra fordon
På vilka klasser skulle ni behöva tillämpa dekomposition för att bättre följa SoC och SRP?
CarController: en för simulering, en för regler, main, mfl
DrawPanel: läsa in bilder sköta grafik, ladda in bilar


Varför är det bättre nu?
Cohesion: tydligare ansvarsområden.
Coupling: minskade beroenden.
DIP: bero inte på specifka bilmodeller (använd interface CarActions)
Framförallt: Cykeln mellan CarController och CarView är bruten genom interfaces.
Controller är inte kopplad till drawpanel.
refaktoriseringsplan:
CarController: ta emot användarinput och uppdatera "fysiken"
CarView: ansvarar för presentation och användarinteraktion
DrawPanel: ritar ut

1. Lägg till interfacet CarActions för att bryta cykeln mellan CarView och CarController. CarView ska bara känna till de knappar den ska ha --> döp om till CarButtons så den endast sköter knapparna. Lägg till InterFacet CarPosition så att Controllern kallar på denna för att uppdatera positionerna som ska ritas ut, och därmed inte känner till DrawPanel. Ritaren DrawPanel implementerar detta interface.
CarButtons till Controller: CarButtons har inte längre CarController carC. Utan CarActions carA. När man trycker på gas så kallar CarButtons på carA.gas(). CarButtons vet inte "vilken" controller som finns, bara att det finns "någon" kontroller.
Controller till DrawPanel: Controllern har en "positioner" som kallar på positioner.update(namn, point). DrawPanel implementerar interfacet och tar emot points och gör målar ut. CarController funkar med vilken ritare som helst.
Detta ökar cohesion och minskar coupling där det blir tydligare ansvarsfördelning och mindre direkta beroenden.
2.  gör så att workshopen kan ta emot vehicles. för att minska beroenden.
3. CarController ska inte bry sig om vilka specifika bilmodeller den arbetar med Workshop<Vehicle>. Så försvinner Use pilar från CarController till volvo, saab, scania.
4. Ta bort Vehicle beroende från DrawPanel. Ta bort moveit och inför istället SetPoints som tar emot bildnamnet och points den ska flyttas till. Då beror inte controller eller vehicle på DrawPanel.


Lab 4:
2:
- I ursprungsversionen är controllern både en controller och en model. Den innehar alla regler för spelet och inputs från viewen. I en förbättrad modell bör den endast ta inputs från viewen, men inte ha reglerna.
- Nej, våra ändringar förbättrade inte MVC alls, utan vi fokuserade på SOC och Inversion Principle.
- Det nya diagrammet delar upp ansvaret för reglerna till carmodel, inputs från viewen till carcontroller och själva framen till drawpanel.

3:
Observer: Mönstret finns oavsiktligen mellan CarView och CarController, eftersom CarView blir ett subjekt där actions sker, och CarController blir en observer som uppdaterar. Vi gjorde detta för att ta bort en cykel och minska coupling (och följa dependency inversion principle), men det blev automatiskt därför och observer pattern.
Observer pattern borde kunna användas för att få bort vehicle beroendet från carModel. Rent logiskt borde alltså antingen bilden eller själva logiken kunna vara en observer till den ena eller andra, för att ta bort beroendet av att bilden efter varje uppdatering uppdateras till nya logiken.

Factory Method: Vi använder inte för närvarande mönstret. Nu skapar vi alla fordon separat i main vilket inte följer factory method, men kan istället skapa ett factory där alla skapas. Så då kommer istället factoryn anropas när ett nytt objekt skapas, och inte enskilt. Coupling och höga beroenden kommer minskas, och förbättringen kommer att gynna dependency inversion principle.

State: Vi använder det för närvarande inte. Vi hade kunnat använda det för båda metoderna TipAble och HasTurbo, för att ta bort beroendena mellan CarModel till de respektive interfacen.

Composite: Vi använder det för närvarande inte. Vi hade kunnat använda composite för att hantera ett grupp av fordon, istället för varje enskilt (t.ex när vi gasar alla bilar i bilden).
